---
title: "Simulation Final"
output: html_notebook
---

# Import Package
```{r}
library(parallel)
library(ggplot2)
library(mev)
library(fields)
```

# mixture model
```{r}
build_Gamma <- function(coord, alpha, theta){
  D <- as.matrix(dist(coord))
  G <- (D / theta)^alpha
  diag(G) <- 0 # \gamma(0) = 0
  return(G)
}

prep_br <- function(Gamma) {
  d <- nrow(Gamma)
  out <- vector("list", d)
  for (j in 1:d) {
    idx <- setdiff(seq_len(d), j)
    Sigj <- ( outer(Gamma[idx, j], rep(1, d-1)) +
                outer(rep(1, d-1), Gamma[idx, j]) -
                Gamma[idx, idx] )
    Sigj <- Sigj + .Machine$double.eps * diag(d-1)
    Lj   <- chol(Sigj)
    out[[j]] <- list(idx = idx, L = Lj, Gamma_col = Gamma[, j])
  }
  out
}

intensity_logskew <- function(x,par,alpha.para=TRUE,log=TRUE){
  sigma = par[[1]]
  if(!is.matrix(x)){x <- matrix(x,nrow=1)}
  n = ncol(x)
  if(n==1) return(1/(x^2))
  omega2 = diag(sigma)
  chol.sigma = chol(sigma)
  inv.sigma = chol2inv(chol.sigma)
  logdet.sigma = sum(log(diag(chol.sigma)))*2
  if(alpha.para){
    alpha = par[[2]]
    delta = c(sigma %*% alpha)/sqrt(c(1+alpha %*% sigma %*% alpha))
  }else{
    delta = par[[2]]
    alpha = c(1 - delta %*% inv.sigma %*% delta)^(-1/2) * c(inv.sigma %*% delta)
  }
  a = log(2) + pnorm(delta,log.p=TRUE)
  q = rowSums(inv.sigma)
  sum.q = sum(q);sum.alpha = sum(alpha)
  q.mat = matrix(q,n,n,byrow=TRUE)
  x.log = log(x)
  x.circ = x.log + matrix(a,nrow=nrow(x),ncol=n,byrow=TRUE)
  beta = (1+sum.alpha^2/sum.q)^(-0.5)
  tau.tilde = apply(x.circ,1,function(x.i)  beta * sum((alpha - sum.alpha*q/sum.q) * (x.i + omega2/2))+ beta*sum.alpha/sum.q)
  A = inv.sigma - q %*% t(q)/sum.q
  val = -(n-3)/2 * log(2) - (n-1)/2*log(pi)-1/2*logdet.sigma - 1/2*log(sum.q) - 1/2 * (sum(q*omega2)-1)/sum.q - 1/8*c(omega2 %*% A %*% omega2) 
  val = val - rowSums(x.log) - 1/2 * apply(x.circ,1,function(x.i) c(x.i %*% A %*% x.i) + sum(x.i * (2*q/sum.q + c(A %*% omega2)))) + pnorm(tau.tilde,log.p=TRUE)
  if(log)
    return(val)
  else
    return(exp(val))    
}

dlog_beta  <- function(x, a, b) dbeta(x, a, b, log = TRUE) # mixture weight prior
dlog_gamma <- function(x, a, b) dgamma(x, shape = a, rate = b, log = TRUE)

component_loglik <- function(X, coord, alpha, theta, anchor = 1){
  Gamma <- build_Gamma(coord = coord, alpha = alpha, theta = theta)
  prep  <- prep_br(Gamma)
  idx   <- prep[[anchor]]$idx
  L     <- prep[[anchor]]$L
  Sigma <- t(L) %*% L
  Xsub  <- as.matrix(X[, idx, drop = FALSE])
  intensity_logskew(
    Xsub, par = list(Sigma, delta = rep(0, ncol(Xsub))),
    alpha.para = FALSE, log = TRUE
  )
}

mix_loglik <- function(X, coord, alpha, th1, th2, anchor = 1) {
  if (!is.finite(th1) || th1 <= 0) return(list(l1 = rep(-Inf, nrow(X)), l2 = rep(-Inf, nrow(X))))
  if (!is.finite(th2) || th2 <= 0) return(list(l1 = rep(-Inf, nrow(X)), l2 = rep(-Inf, nrow(X))))
  l1 <- component_loglik(X, coord, alpha = alpha, theta = th1, anchor = anchor)
  l2 <- component_loglik(X, coord, alpha = alpha, theta = th2, anchor = anchor)
  list(l1 = l1, l2 = l2)
}

tau_from_ll <- function(l1, l2, lambda) {
  a <- log(lambda)     + l1
  b <- log(1 - lambda) + l2
  m <- pmax(a, b)
  exp(a - m) / (exp(a - m) + exp(b - m))
}

mcmc_br <- function(
    data, coord, alpha,
    n_iter   = 4000,
    burn     = 1000,
    thin     = 2,
    # priors
    a_lambda = 1, b_lambda = 1,   # for mixture weight lambda
    a_th2 = 1, b_th2 = 1,         # for theta2
    a_del = 1, b_del = 1,         # for delta
    # proposal sds on log-scale
    prop_sd_log_th2  = 0.10,
    prop_sd_log_del  = 0.10,
    # initials
    init_lambda = 0.5,  # mixture weight
    init_th2    = 15,   # theta2
    init_del    = 20,   # delta
    anchor = 1,
    verbose_every = 100
){
  stopifnot(init_lambda > 0, init_lambda < 1, init_th2 > 0, init_del > 0)
  
  keep_idx <- seq.int(burn + 1, n_iter, by = thin)
  n_keep   <- length(keep_idx)
  
  draws <- data.frame(
    iter     = keep_idx,
    lambda   = NA_real_,   # mixture weight
    theta1   = NA_real_,
    theta2   = NA_real_
  )
  z_draws <- matrix(NA_integer_, nrow = n_keep, ncol = nrow(data))
  tau_bar <- rep(0, nrow(data))
  
  # init
  lambda <- init_lambda
  th2    <- init_th2
  del    <- init_del
  th1    <- th2 + del
  
  ll  <- mix_loglik(X = data, coord = coord, alpha = alpha, th1 = th1, th2 = th2, anchor = anchor)
  tau <- tau_from_ll(ll$l1, ll$l2, lambda = lambda)
  z   <- rbinom(n = length(tau), size = 1, prob = tau)
  
  acc_block <- 0L; n_prop <- 0L
  
  # helper: complete-data log-posterior in η-space (η2=log θ2, ηd=log δ)
  logpost_eta <- function(eta2, etad, z_vec) {
    th2p <- exp(eta2)
    delp <- exp(etad)
    th1p <- th2p + delp
    
    llp <- mix_loglik(X = data, coord = coord, alpha = alpha,
                      th1 = th1p, th2 = th2p, anchor = anchor)
    
    lp_ll    <- sum(z_vec * llp$l1 + (1 - z_vec) * llp$l2)
    lp_prior <- dlog_gamma(th2p, a_th2, b_th2) + dlog_gamma(delp, a_del, b_del)
    lp_jac   <- eta2 + etad
    list(value = lp_ll + lp_prior + lp_jac,
         th1 = th1p, th2 = th2p, del = delp, l1_vec = llp$l1, l2_vec = llp$l2)
  }
  
  keep_cursor <- 1L
  for (it in seq_len(n_iter)) {
    
    ## (1) blocked MH for (θ2, δ) on log-scale
    n_prop <- n_prop + 1L
    eta2  <- log(th2);  etad <- log(del)
    eta2p <- rnorm(1, mean = eta2, sd = prop_sd_log_th2)
    etadp <- rnorm(1, mean = etad, sd = prop_sd_log_del)
    
    # current value via same function
    curr <- logpost_eta(eta2, etad, z)
    prop <- logpost_eta(eta2p, etadp, z)
    
    if (log(runif(1)) < (prop$value - curr$value)) {
      th2 <- prop$th2;  del <- prop$del;  th1 <- prop$th1
      ll$l1 <- prop$l1_vec; ll$l2 <- prop$l2_vec
      acc_block <- acc_block + 1L
    }
    # else keep (th1,th2,del,ll) as-is
    
    ## (2) Gibbs for lambda | z (Beta-conjugate)
    n1 <- sum(z); n0 <- length(z) - n1
    lambda <- rbeta(1, a_lambda + n1, b_lambda + n0)
    
    ## (3) Gibbs for z | x, θ, λ
    tau <- tau_from_ll(ll$l1, ll$l2, lambda)
    z   <- rbinom(length(tau), 1, tau)
    
    ## store thinned draws
    if (it %in% keep_idx) {
      tau_bar <- tau_bar + tau / n_keep
      draws$lambda[keep_cursor] <- lambda
      draws$theta1[keep_cursor] <- th1
      draws$theta2[keep_cursor] <- th2
      z_draws[keep_cursor, ]    <- z
      keep_cursor <- keep_cursor + 1L
    }
    
    if (verbose_every > 0 && it %% verbose_every == 0) {
      cat(sprintf("iter %d | lambda=%.3f θ1=%.3f θ2=%.3f | acc(θ-block)=%.3f\n",
                  it, lambda, th1, th2, acc_block / n_prop))
    }
  }
  
  list(
    draws = draws,
    z_draws = z_draws,
    accept_rate_theta_block = acc_block / n_prop,
    tau_bar = tau_bar,
    hard_labels = ifelse(tau_bar > 0.5, 1, 2),
    post_mean = c(lambda = mean(draws$lambda),
                  theta1 = mean(draws$theta1),
                  theta2 = mean(draws$theta2)),
    post_median = c(lambda = median(draws$lambda),
                    theta1 = median(draws$theta1),
                    theta2 = median(draws$theta2))
  )
}
```



# time variant $\pi$
```{r}
pi_t_generator <- function(T){
  return (0.5 -  0.5*sin(T))
}

time_variant_sample_generator <- function(pi_t, prep1, prep2){
  T <- length(pi_t)
  
  z  <- integer(T)
  x  <- vector("list", T)
  
  for (t in seq_len(T)){
    pi <- pi_t[t]
    z[t] = rbinom(1,1,pi)
    if (z[t] == 1){
      x[[t]] <- simulate_rpareto_mean(m = 1, prep = prep1)
    }
    else{
      x[[t]] <- simulate_rpareto_mean(m = 1, prep = prep2)
    }
  }
  
  list(x = x, z = z)
}
```

```{r}
simulate_rpareto_mean <- function(m, prep) {
  d <- length(prep)
  one <- function() {
    # J   <- sample.int(d, 1)
    J <- 1
    idx <- prep[[J]]$idx
    L   <- prep[[J]]$L
    Gcol<- prep[[J]]$Gamma_col
    g   <- rep(0, d); g[idx] <- drop(t(L) %*% rnorm(d-1))
    y   <- exp(g - Gcol); y <- y / y[J]     # Y^{(J)}, with y_J=1
    v   <- y / sum(y)                       # angular on ℓ1-simplex
    r   <- evd::rgpd(1, loc = 1, scale = 1, shape = 1)  # Pareto(1)
    r * v
  }
  Z <- replicate(m, one())
  t(Z)
}
```


## Two distingushable component
```{r}
set.seed(123)
theta1 = 50
theta2 = 25
alpha = 1.5
lam_mix = 0.7


lon <- seq(1,100, length = 10)
lat <- seq(1,100, length = 10)
grid <- expand.grid(lon,lat)
coord <- as.matrix(grid)


Gamma1 <- build_Gamma(coord = coord, alpha = alpha, theta = theta1)
Gamma2 <- build_Gamma(coord = coord, alpha = alpha, theta = theta2)

prep1 <- prep_br(Gamma1)
prep2 <- prep_br(Gamma2)

M = 2000
m1 = as.integer(M*lam_mix)
m2 = as.integer(M*(1-lam_mix))

simu1 <- simulate_rpareto_mean(m = m1, prep = prep1)
simu2 <- simulate_rpareto_mean(m = m2, prep = prep2)

Xmix <- rbind(simu1, simu2)
true_z <- rbind(rep(1,nrow(simu1)), rep(2, nrow(simu2)))

ix   <- sample(nrow(Xmix))
Xmix <- Xmix[ix, , drop = FALSE]
true_z <- true_z[ix]
```

```{r}
set.seed(123)

# Run MCMC
fit1 <- mcmc_br(
  data = Xmix, coord = coord, alpha = alpha,
  n_iter = 5000, burn = 1000, thin = 2,
  a_lambda = 1, b_lambda = 1,       
  a_th2 = 1, b_th2 = 1,      
  a_del = 1, b_del = 1,    
  init_th2 = 10,
  init_del = 35,
  prop_sd_log_th2  = 0.01,    
  prop_sd_log_del = 0.01,
  anchor = 1,
  verbose_every = 50
)
```
```{r}
df <- fit1$draws
g1 <- ggplot(df, aes(iter, theta1)) + geom_line() +
  labs(title = expression(trace~theta[1]))
g2 <- ggplot(df, aes(iter, theta2)) + geom_line() +
  labs(title = expression(trace~theta[2]))
g3 <- ggplot(df, aes(iter, lambda)) + geom_line() +
  labs(title = expression(trace~lambda))
gd1 <- ggplot(df, aes(theta1)) + geom_density() +
  labs(title = expression(density~theta[1]))
gd2 <- ggplot(df, aes(theta2)) + geom_density() +
  labs(title = expression(density~theta[2]))
gd3 <- ggplot(df, aes(lambda)) + geom_density() +
  labs(title = expression(density~lambda))

gridExtra::grid.arrange(g1,g2,g3, gd1,gd2,gd3, ncol = 3)
```

```{r}
df <- fit1$draws

# 1. Trace Plots (Use geom_hline for a fixed Y-value)
g1 <- ggplot(df, aes(iter, theta1)) + geom_line() +
  labs(title = expression(trace~theta[1])) +
  geom_hline(yintercept = theta1, color = "red", linetype = "dashed", linewidth = 1)
  
g2 <- ggplot(df, aes(iter, theta2)) + geom_line() +
  labs(title = expression(trace~theta[2])) +
  geom_hline(yintercept = theta2, color = "red", linetype = "dashed", linewidth = 1)

g3 <- ggplot(df, aes(iter, lambda)) + geom_line() +
  labs(title = expression(trace~lambda)) +
  geom_hline(yintercept = lam_mix, color = "red", linetype = "dashed", linewidth = 1)


# 2. Density Plots (Use geom_vline for a fixed X-value)
gd1 <- ggplot(df, aes(theta1)) + geom_density() +
  labs(title = expression(density~theta[1])) +
  geom_vline(xintercept = theta1, color = "red", linetype = "dashed", linewidth = 1)
  
gd2 <- ggplot(df, aes(theta2)) + geom_density() +
  labs(title = expression(density~theta[2])) +
  geom_vline(xintercept = theta2, color = "red", linetype = "dashed", linewidth = 1)
  
gd3 <- ggplot(df, aes(lambda)) + geom_density() +
  labs(title = expression(density~lambda)) +
  geom_vline(xintercept = lam_mix, color = "red", linetype = "dashed", linewidth = 1)


# Arrange and plot
gridExtra::grid.arrange(g1,g2,g3, gd1,gd2,gd3, ncol = 3)
```
```{r}
fit1$post_mean
```


```{r}
idx = c(1, 34, 56, 201, 344, 1002)
z_draw <- as.matrix(fit1$z_draws)
z_draw <- data.frame(z_draw[,idx])

par(mfrow = c(3,2))

for (i in 1:ncol(z_draw)){
  plot(z_draw[,i], type = 'l')
}
```



```{r}
chi_q <- function(X, q = 0.98) {
  n <- ncol(X)
  m <- nrow(X)
  
  # thresholds at site level
  u <- apply(X, 2, quantile, probs = q, na.rm = TRUE)
  
  # initialize matrix
  chi_hat <- matrix(NA, n, n)
  
  for (i in 1:(n-1)) {
    for (j in (i+1):n) {
      Ai <- X[, i] > u[i]
      Aj <- X[, j] > u[j]
      chi_hat[i, j] <- mean(Ai & Aj) / mean(Ai)
      chi_hat[j, i] <- chi_hat[i, j]
    }
  }
  diag(chi_hat) <- 1
  chi_hat
}

dist_matrix <- as.matrix(dist(coord))

stopifnot(length(fit1$hard_labels) == nrow(Xmix))
labs <- fit1$hard_labels

X1 <- Xmix[labs == 1, , drop = FALSE]
X2 <- Xmix[labs == 2, , drop = FALSE]

# 4) compute χ̂_q for both comps and two q levels
chi_95_c1 <- chi_q(X1, q = 0.95)
chi_95_c2 <- chi_q(X2, q = 0.95)
chi_90_c1 <- chi_q(X1, q = 0.90)
chi_90_c2 <- chi_q(X2, q = 0.90)


upper_to_df <- function(chi_mat, dist_mat, q_label, comp_label) {
  idx <- which(upper.tri(chi_mat), arr.ind = TRUE)
  tibble(
    dist = dist_mat[idx],
    chi  = chi_mat[idx],
    q    = q_label,
    comp = comp_label
  ) %>% filter(is.finite(chi))
}

df_all <- bind_rows(
  upper_to_df(chi_95_c1, dist_matrix, "q=0.95", "Comp1"),
  upper_to_df(chi_95_c2, dist_matrix, "q=0.95", "Comp2"),
  upper_to_df(chi_90_c1, dist_matrix, "q=0.90", "Comp1"),
  upper_to_df(chi_90_c2, dist_matrix, "q=0.90", "Comp2"),

)

# 6) plot (mirrors your original style)
ggplot(df_all, aes(x = dist, y = chi, color = comp)) +
  geom_point(alpha = 0.4, size = 0.6) +
  facet_wrap(~ q, scales = "free_y") +
  theme_bw() +
  labs(
    x = expression(h(s[A], s[B])),
    y = expression(hat(chi)[q](s[A], s[B])),
    title = "Empirical " %+% expression(hat(chi)[q]) %+% " vs Distance by MCMC Hard-Label Component"
  ) +
  scale_color_manual(values = c("Comp1" = "blue", "Comp2" = "red"))
```
```{r}
set.seed(123)
theta1 = 50
theta2 = 40
alpha = 1.5
lam_mix = 0.7


lon <- seq(1,100, length = 10)
lat <- seq(1,100, length = 10)
grid <- expand.grid(lon,lat)
coord <- as.matrix(grid)


Gamma1 <- build_Gamma(coord = coord, alpha = alpha, theta = theta1)
Gamma2 <- build_Gamma(coord = coord, alpha = alpha, theta = theta2)

prep1 <- prep_br(Gamma1)
prep2 <- prep_br(Gamma2)

M = 2000
m1 = as.integer(M*lam_mix)
m2 = as.integer(M*(1-lam_mix))

simu1 <- simulate_rpareto_mean(m = m1, prep = prep1)
simu2 <- simulate_rpareto_mean(m = m2, prep = prep2)

Xmix <- rbind(simu1, simu2)
true_z <- rbind(rep(1,nrow(simu1)), rep(2, nrow(simu2)))

ix   <- sample(nrow(Xmix))
Xmix <- Xmix[ix, , drop = FALSE]
true_z <- true_z[ix]
```
```{r}
set.seed(123)

# Run MCMC
fit2 <- mcmc_br(
  data = Xmix, coord = coord, alpha = alpha,
  n_iter = 5000, burn = 1000, thin = 2,
  a_lambda = 1, b_lambda = 1,       
  a_th2 = 1, b_th2 = 1,      
  a_del = 1, b_del = 1,    
  init_th2 = 35,
  init_del = 10,
  prop_sd_log_th2  = 0.01,    
  prop_sd_log_del = 0.01,
  anchor = 1,
  verbose_every = 50
)
```

```{r}
df <- fit2$draws

# 1. Trace Plots (Use geom_hline for a fixed Y-value)
g1 <- ggplot(df, aes(iter, theta1)) + geom_line() +
  labs(title = expression(trace~theta[1])) +
  geom_hline(yintercept = theta1, color = "red", linetype = "dashed", linewidth = 1)
  
g2 <- ggplot(df, aes(iter, theta2)) + geom_line() +
  labs(title = expression(trace~theta[2])) +
  geom_hline(yintercept = theta2, color = "red", linetype = "dashed", linewidth = 1)

g3 <- ggplot(df, aes(iter, lambda)) + geom_line() +
  labs(title = expression(trace~lambda)) +
  geom_hline(yintercept = lam_mix, color = "red", linetype = "dashed", linewidth = 1)


# 2. Density Plots (Use geom_vline for a fixed X-value)
gd1 <- ggplot(df, aes(theta1)) + geom_density() +
  labs(title = expression(density~theta[1])) +
  geom_vline(xintercept = theta1, color = "red", linetype = "dashed", linewidth = 1)
  
gd2 <- ggplot(df, aes(theta2)) + geom_density() +
  labs(title = expression(density~theta[2])) +
  geom_vline(xintercept = theta2, color = "red", linetype = "dashed", linewidth = 1)
  
gd3 <- ggplot(df, aes(lambda)) + geom_density() +
  labs(title = expression(density~lambda)) +
  geom_vline(xintercept = lam_mix, color = "red", linetype = "dashed", linewidth = 1)


# Arrange and plot
gridExtra::grid.arrange(g1,g2,g3, gd1,gd2,gd3, ncol = 3)
```

```{r}
fit2$post_mean
```
```{r}
idx = c(1, 34, 56, 201, 344, 1002)
z_draw <- as.matrix(fit2$z_draws)
z_draw <- data.frame(z_draw[,idx])

par(mfrow = c(3,2))

for (i in 1:ncol(z_draw)){
  plot(z_draw[,i], type = 'l')
}
```
```{r}
Ms = c(500, 1000, 2000)

fits <- list() 

for (M in Ms){
  cat(">>> Fitting model for M =", M, "...\n")
  m1 = as.integer(M*lam_mix)
  m2 = as.integer(M*(1-lam_mix))
  
  simu1 <- simulate_rpareto_mean(m = m1, prep = prep1)
  simu2 <- simulate_rpareto_mean(m = m2, prep = prep2)
  
  Xmix <- rbind(simu1, simu2)
  
  ix   <- sample(nrow(Xmix))
  Xmix <- Xmix[ix, , drop = FALSE]
  
  fit <- mcmc_br(
  data = Xmix, coord = coord, alpha = alpha,
  n_iter = 5000, burn = 1000, thin = 2,
  a_lambda = 1, b_lambda = 1,       
  a_th2 = 1, b_th2 = 1,      
  a_del = 1, b_del = 1,    
  init_th2 = 35,
  init_del = 10,
  prop_sd_log_th2  = 0.01,    
  prop_sd_log_del = 0.01,
  anchor = 1,
  verbose_every = 50
 )
  
  fits[[paste0("M", M)]] <- fit
}
```
```{r}
draws_long <- imap_dfr(fits, function(fit, name) {
  fit$draws %>%
    transmute(theta1, theta2, lambda) %>%
    mutate(fit = name)
})

# Reshape for plotting
draws_long <- draws_long %>%
  pivot_longer(c(theta1, theta2, lambda),
               names_to = "param",
               values_to = "value")

# Ground-truth reference lines
truth_tbl <- tibble::tibble(
  param = c("theta1","theta2","lambda"),
  truth = c(theta1, theta2, lam_mix)
)

# Plot
p <- ggplot(draws_long, aes(x = value, color = fit, fill = fit)) +
  geom_density(alpha = 0.18, linewidth = 1) +
  geom_vline(data = truth_tbl,
             aes(xintercept = truth),
             linetype = 2, linewidth = 0.6, inherit.aes = FALSE) +
  facet_wrap(~ param, scales = "free", nrow = 1,
             labeller = labeller(param = c(lambda1 = expression(theta[1]),
                                           lambda2 = expression(theta[2]),
                                           pi      = expression(lambda)))) +
  labs(title = "Posterior densities across sample sizes",
       x = "Value", y = "Density",
       color = "Fit", fill = "Fit") +
  theme_bw() +
  theme(strip.text = element_text(size = 12),
        plot.title = element_text(hjust = 0.5))

print(p)
```

